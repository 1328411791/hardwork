C51 COMPILER V9.60.7.0   RICHBOT_TIMER                                                     12/19/2023 09:15:26 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE RICHBOT_TIMER
OBJECT MODULE PLACED IN .\Objects\RICHBOT_timer.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE System\RICHBOT_timer.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\User;.\Sy
                    -stem) DEBUG OBJECTEXTEND PRINT(.\Listings\RICHBOT_timer.lst) TABS(2) OBJECT(.\Objects\RICHBOT_timer.obj)

line level    source

   1          #include "global.h"
   2          
   3          /*System ticks*/
   4          static volatile unsigned long idata g_sys_ticks;
   5          static unsigned int code g_timer0_init_val = 65536UL - (CFG_SYSFREQ/12/1000);
   6          /*Timer 0 as system tick timer. 1KHZ */
   7          void SysTick_Init(void) {
   8   1        TIM_InitTypeDef   TIM_InitStructure;          //½á¹¹¶¨Òå
   9   1        TIM_InitStructure.TIM_Mode      = TIM_16Bit;      //Ö¸¶¨¹¤×÷Ä£Ê½,   TIM_16BitAutoReload,TIM_16Bit,TIM_8BitAu
             -toReload,TIM_16BitAutoReloadNoMask
  10   1        TIM_InitStructure.TIM_Polity    = PolityHigh;     //Ö¸¶¨ÖÐ¶ÏÓÅÏÈ¼¶, PolityHigh,PolityLow
  11   1        TIM_InitStructure.TIM_Interrupt = ENABLE;       //ÖÐ¶ÏÊÇ·ñÔÊÐí,   ENABLE»òDISABLE
  12   1        TIM_InitStructure.TIM_ClkSource = TIM_CLOCK_12T;      //Ö¸¶¨Ê±ÖÓÔ´,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK
             -_Ext
  13   1        TIM_InitStructure.TIM_ClkOut    = DISABLE;        //ÊÇ·ñÊä³ö¸ßËÙÂö³å, ENABLE»òDISABLE
  14   1        TIM_InitStructure.TIM_Value     = g_timer0_init_val;  //³õÖµ,
  15   1        TIM_InitStructure.TIM_Run       = ENABLE;       //ÊÇ·ñ³õÊ¼»¯ºóÆô¶¯¶¨Ê±Æ÷, ENABLE»òDISABLE
  16   1        Timer_Inilize(Timer0,&TIM_InitStructure);       //³õÊ¼»¯Timer0    Timer0,Timer1,Timer2
  17   1      }
  18          
  19          void timer0_ISR(void) interrupt 1
  20          {
  21   1        TL0 = g_timer0_init_val & 0xff;
  22   1        TH0 = g_timer0_init_val >> 8; 
  23   1        g_sys_ticks ++;
  24   1      }
  25          
  26          uint32_t time_GetTicks(void)
  27          {
  28   1        unsigned long ticks;
  29   1        EA = 0;
  30   1        ticks = g_sys_ticks;
  31   1        EA = 1;
  32   1        return ticks;
  33   1      }
  34          
  35          #if (CFG_SYSFREQ == 22118400 && INS_VER == INS_VER_Y5)
  36          static void Delay1us()
  37          {
  38   1        unsigned char i;
  39   1      
  40   1        i = 3;
  41   1        while (--i);
  42   1      }
  43          static void Delay10us()
  44          {
  45   1        unsigned char i;
  46   1      
  47   1        _nop_();
  48   1        _nop_();
  49   1        _nop_();
  50   1        i = 52;
  51   1        while (--i);
  52   1      }
C51 COMPILER V9.60.7.0   RICHBOT_TIMER                                                     12/19/2023 09:15:26 PAGE 2   

  53          static void Delay100us()
  54          {
  55   1        unsigned char i, j;
  56   1      
  57   1        i = 3;
  58   1        j = 26;
  59   1        do
  60   1        {
  61   2          while (--j);
  62   2        } while (--i);
  63   1      }
  64          #endif
  65          
  66          void DelayUs(uint16_t us)
  67          {
  68   1        for(;us>=100;us-=100) Delay100us();
  69   1        for(;us>=10;us-=10) Delay10us();
  70   1        for(;us>0;us--) Delay1us();
  71   1      }
  72          
  73          void DelayMs(uint16_t ms) {
  74   1        uint32_t oldticks;
  75   1        uint32_t ticks;
  76   1        oldticks  = time_GetTicks();
  77   1        do {
  78   2          ticks = time_GetTicks();
  79   2        } while (ticks - oldticks < ms);
  80   1      }
  81          
  82          
  83          #if(CPU_TYPE == CPU_TYPE_STC89)
              
              int Timer_Inilize(uint8_t TIM, TIM_InitTypeDef *TIMx)
              {
                if(TIM > Timer2)  return 1; //¿Õ²Ù×÷
              
                if(TIM == Timer0)
                {
                  TR0 = 0;    //Í£Ö¹¼ÆÊý
                  if(TIMx->TIM_Interrupt == ENABLE)   ET0 = 1;  //ÔÊÐíÖÐ¶Ï
                  else                  ET0 = 0;  //½ûÖ¹ÖÐ¶Ï
                  if(TIMx->TIM_Polity == PolityHigh)    PT0 = 1;  //¸ßÓÅÏÈ¼¶ÖÐ¶Ï
                  else                  PT0 = 0;  //µÍÓÅÏÈ¼¶ÖÐ¶Ï
                  if(TIMx->TIM_Mode >  TIM_16BitAutoReloadNoMask) return 2; //´íÎó
                  TMOD = (TMOD & ~0x03) | TIMx->TIM_Mode; //¹¤×÷Ä£Ê½,0: 16Î»×Ô¶¯ÖØ×°, 1: 16Î»¶¨Ê±/¼ÆÊý, 2: 8Î»×Ô¶¯ÖØ×°, 3:
             - 16Î»×Ô¶¯ÖØ×°, ²»¿ÉÆÁ±ÎÖÐ¶Ï
              
                  
                  TH0 = (uint8_t)(TIMx->TIM_Value >> 8);
                  TL0 = (uint8_t)TIMx->TIM_Value;
                  if(TIMx->TIM_Run == ENABLE) TR0 = 1;  //¿ªÊ¼ÔËÐÐ
                  return  0;    //³É¹¦
                }
              
                if(TIM == Timer1)
                {
                  TR1 = 0;    //Í£Ö¹¼ÆÊý
                  if(TIMx->TIM_Interrupt == ENABLE)   ET1 = 1;  //ÔÊÐíÖÐ¶Ï
                  else                  ET1 = 0;  //½ûÖ¹ÖÐ¶Ï
                  if(TIMx->TIM_Polity == PolityHigh)    PT1 = 1;  //¸ßÓÅÏÈ¼¶ÖÐ¶Ï
                  else                  PT1 = 0;  //µÍÓÅÏÈ¼¶ÖÐ¶Ï
                  if(TIMx->TIM_Mode >= TIM_16BitAutoReloadNoMask) return 2; //´íÎó
C51 COMPILER V9.60.7.0   RICHBOT_TIMER                                                     12/19/2023 09:15:26 PAGE 3   

                  TMOD = (TMOD & ~0x30) | (TIMx->TIM_Mode << 4);  //¹¤×÷Ä£Ê½,0: 16Î»×Ô¶¯ÖØ×°, 1: 16Î»¶¨Ê±/¼ÆÊý, 2: 8Î»×Ô¶¯Ö
             -Ø×°
                  TH1 = (uint8_t)(TIMx->TIM_Value >> 8);
                  TL1 = (uint8_t)TIMx->TIM_Value;
                  if(TIMx->TIM_Run == ENABLE) TR1 = 1;  //¿ªÊ¼ÔËÐÐ
                  return  0;    //³É¹¦
                }
              
                if(TIM == Timer2)   //Timer2,¹Ì¶¨Îª16Î»×Ô¶¯ÖØ×°, ÖÐ¶ÏÎÞÓÅÏÈ¼¶
                {
                  AUXR &= ~(1<<4);  //Í£Ö¹¼ÆÊý
                  if(TIMx->TIM_Interrupt == ENABLE)     IE2  |=  (1<<2);  //ÔÊÐíÖÐ¶Ï
                  else                    IE2  &= ~(1<<2);  //½ûÖ¹ÖÐ¶Ï
              
                  TH2 = (uint8_t)(TIMx->TIM_Value >> 8);
                  TL2 = (uint8_t)TIMx->TIM_Value;
                  if(TIMx->TIM_Run == ENABLE) AUXR |=  (1<<4);  //¿ªÊ¼ÔËÐÐ
                  return  0;    //³É¹¦
                }
                return 2; //´íÎó
              }
              
              #elseif (CPU_TYPE == CPU_TYPE_STC15)
              
              int Timer_Inilize(uint8_t TIM, TIM_InitTypeDef *TIMx)
              {
                if(TIM > Timer3)  return 1; //¿Õ²Ù×÷
              
                if(TIM == Timer0)
                {
                  TR0 = 0;    //Í£Ö¹¼ÆÊý
                  if(TIMx->TIM_Interrupt == ENABLE)   ET0 = 1;  //ÔÊÐíÖÐ¶Ï
                  else                  ET0 = 0;  //½ûÖ¹ÖÐ¶Ï
                  if(TIMx->TIM_Polity == PolityHigh)    PT0 = 1;  //¸ßÓÅÏÈ¼¶ÖÐ¶Ï
                  else                  PT0 = 0;  //µÍÓÅÏÈ¼¶ÖÐ¶Ï
                  if(TIMx->TIM_Mode >  TIM_16BitAutoReloadNoMask) return 2; //´íÎó
                  TMOD = (TMOD & ~0x03) | TIMx->TIM_Mode; //¹¤×÷Ä£Ê½,0: 16Î»×Ô¶¯ÖØ×°, 1: 16Î»¶¨Ê±/¼ÆÊý, 2: 8Î»×Ô¶¯ÖØ×°, 3:
             - 16Î»×Ô¶¯ÖØ×°, ²»¿ÉÆÁ±ÎÖÐ¶Ï
                  if(TIMx->TIM_ClkSource == TIM_CLOCK_12T)  AUXR &= ~0x80;  //12T
                  if(TIMx->TIM_ClkSource == TIM_CLOCK_1T)   AUXR |=  0x80;  //1T
                  if(TIMx->TIM_ClkSource == TIM_CLOCK_Ext)  TMOD |=  0x04;  //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
                  else                    TMOD &= ~0x04;  //¶¨Ê±
                  if(TIMx->TIM_ClkOut == ENABLE)  INT_CLKO |=  0x01;  //Êä³öÊ±ÖÓ
                  else              INT_CLKO &= ~0x01;  //²»Êä³öÊ±ÖÓ
                  
                  TH0 = (uint8_t)(TIMx->TIM_Value >> 8);
                  TL0 = (uint8_t)TIMx->TIM_Value;
                  if(TIMx->TIM_Run == ENABLE) TR0 = 1;  //¿ªÊ¼ÔËÐÐ
                  return  0;    //³É¹¦
                }
              
                if(TIM == Timer1)
                {
                  TR1 = 0;    //Í£Ö¹¼ÆÊý
                  if(TIMx->TIM_Interrupt == ENABLE)   ET1 = 1;  //ÔÊÐíÖÐ¶Ï
                  else                  ET1 = 0;  //½ûÖ¹ÖÐ¶Ï
                  if(TIMx->TIM_Polity == PolityHigh)    PT1 = 1;  //¸ßÓÅÏÈ¼¶ÖÐ¶Ï
                  else                  PT1 = 0;  //µÍÓÅÏÈ¼¶ÖÐ¶Ï
                  if(TIMx->TIM_Mode >= TIM_16BitAutoReloadNoMask) return 2; //´íÎó
                  TMOD = (TMOD & ~0x30) | (TIMx->TIM_Mode << 4);  //¹¤×÷Ä£Ê½,0: 16Î»×Ô¶¯ÖØ×°, 1: 16Î»¶¨Ê±/¼ÆÊý, 2: 8Î»×Ô¶¯Ö
             -Ø×°
                  if(TIMx->TIM_ClkSource == TIM_CLOCK_12T)  AUXR &= ~0x40;  //12T
C51 COMPILER V9.60.7.0   RICHBOT_TIMER                                                     12/19/2023 09:15:26 PAGE 4   

                  if(TIMx->TIM_ClkSource == TIM_CLOCK_1T)   AUXR |=  0x40;  //1T
                  if(TIMx->TIM_ClkSource == TIM_CLOCK_Ext)  TMOD |=  0x40;  //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
                  else                    TMOD &= ~0x40;  //¶¨Ê±
                  if(TIMx->TIM_ClkOut == ENABLE)  INT_CLKO |=  0x02;  //Êä³öÊ±ÖÓ
                  else              INT_CLKO &= ~0x02;  //²»Êä³öÊ±ÖÓ
                  
                  TH1 = (uint8_t)(TIMx->TIM_Value >> 8);
                  TL1 = (uint8_t)TIMx->TIM_Value;
                  if(TIMx->TIM_Run == ENABLE) TR1 = 1;  //¿ªÊ¼ÔËÐÐ
                  return  0;    //³É¹¦
                }
              
                if(TIM == Timer2)   
                {
                  AUXR &= ~(1<<4);  //Í£Ö¹¼ÆÊý
                  if(TIMx->TIM_Interrupt == ENABLE)     IE2  |=  (1<<2);  //ÔÊÐíÖÐ¶Ï
                  else                    IE2  &= ~(1<<2);  //½ûÖ¹ÖÐ¶Ï
                  if(TIMx->TIM_ClkSource >  TIM_CLOCK_Ext)  return 2;
                  if(TIMx->TIM_ClkSource == TIM_CLOCK_12T)  AUXR &= ~(1<<2);  //12T
                  if(TIMx->TIM_ClkSource == TIM_CLOCK_1T)   AUXR |=  (1<<2);  //1T
                  if(TIMx->TIM_ClkSource == TIM_CLOCK_Ext)  AUXR |=  (1<<3);  //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
                  else                    AUXR &= ~(1<<3);  //¶¨Ê±
                  if(TIMx->TIM_ClkOut == ENABLE)  INT_CLKO |=  0x04;  //Êä³öÊ±ÖÓ
                  else              INT_CLKO &= ~0x04;  //²»Êä³öÊ±ÖÓ
              
                  T2H = (uint8_t)(TIMx->TIM_Value >> 8);
                  T2L = (uint8_t)TIMx->TIM_Value;
                  if(TIMx->TIM_Run == ENABLE) AUXR |=  (1<<4);  //¿ªÊ¼ÔËÐÐ
                  return  0;    //³É¹¦
                }
                /*STC15F2KÃ»ÓÐ¶¨Ê±Æ÷3*/
              //  if(TIM == Timer3)   
              //  {
              //    T4T3M &= ~(1<<3); //Í£Ö¹¼ÆÊý
              //    if(TIMx->TIM_Interrupt == ENABLE)     IE2  |=  (1<<5);  //ÔÊÐíÖÐ¶Ï
              //    else                    IE2  &= ~(1<<5);  //½ûÖ¹ÖÐ¶Ï
              //    if(TIMx->TIM_ClkSource >  TIM_CLOCK_Ext)  return 2;
              //    if(TIMx->TIM_ClkSource == TIM_CLOCK_12T)  T4T3M  &= ~(1<<1);  //12T
              //    if(TIMx->TIM_ClkSource == TIM_CLOCK_1T)   T4T3M  |=  (1<<1);  //1T
              //    if(TIMx->TIM_ClkSource == TIM_CLOCK_Ext)  T4T3M  |=  (1<<2);  //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
              //    else                    T4T3M  &= ~(1<<2);  //¶¨Ê±
              //    if(TIMx->TIM_ClkOut == ENABLE)  T4T3M |=  0x01; //Êä³öÊ±ÖÓ
              //    else              T4T3M &= ~0x01; //²»Êä³öÊ±ÖÓ
              
              //    T3H = (uint8_t)(TIMx->TIM_Value >> 8);
              //    T3L = (uint8_t)TIMx->TIM_Value;
              //    if(TIMx->TIM_Run == ENABLE) T4T3M  |=  (1<<3);  //¿ªÊ¼ÔËÐÐ
              //    return  0;    //³É¹¦
              //  }
                return 2; //´íÎó
              }
              
              #else
 226          
 227          int Timer_Inilize(uint8_t TIM, TIM_InitTypeDef *TIMx)
 228          {
 229   1        if(TIM > Timer2)  return 1; //¿Õ²Ù×÷
 230   1      
 231   1        if(TIM == Timer0)
 232   1        {
 233   2          TR0 = 0;    //Í£Ö¹¼ÆÊý
 234   2          if(TIMx->TIM_Interrupt == ENABLE)   ET0 = 1;  //ÔÊÐíÖÐ¶Ï
C51 COMPILER V9.60.7.0   RICHBOT_TIMER                                                     12/19/2023 09:15:26 PAGE 5   

 235   2          else                  ET0 = 0;  //½ûÖ¹ÖÐ¶Ï
 236   2          if(TIMx->TIM_Polity == PolityHigh)    PT0 = 1;  //¸ßÓÅÏÈ¼¶ÖÐ¶Ï
 237   2          else                  PT0 = 0;  //µÍÓÅÏÈ¼¶ÖÐ¶Ï
 238   2          if(TIMx->TIM_Mode >  TIM_16BitAutoReloadNoMask) return 2; //´íÎó
 239   2          TMOD = (TMOD & ~0x03) | TIMx->TIM_Mode; //¹¤×÷Ä£Ê½,0: 16Î»×Ô¶¯ÖØ×°, 1: 16Î»¶¨Ê±/¼ÆÊý, 2: 8Î»×Ô¶¯ÖØ×°, 3:
             - 16Î»×Ô¶¯ÖØ×°, ²»¿ÉÆÁ±ÎÖÐ¶Ï
 240   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_12T)  AUXR &= ~0x80;  //12T
 241   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_1T)   AUXR |=  0x80;  //1T
 242   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_Ext)  TMOD |=  0x04;  //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
 243   2          else                    TMOD &= ~0x04;  //¶¨Ê±
 244   2          if(TIMx->TIM_ClkOut == ENABLE)  INT_CLKO |=  0x01;  //Êä³öÊ±ÖÓ
 245   2          else              INT_CLKO &= ~0x01;  //²»Êä³öÊ±ÖÓ
 246   2          
 247   2          TH0 = (uint8_t)(TIMx->TIM_Value >> 8);
 248   2          TL0 = (uint8_t)TIMx->TIM_Value;
 249   2          if(TIMx->TIM_Run == ENABLE) TR0 = 1;  //¿ªÊ¼ÔËÐÐ
 250   2          return  0;    //³É¹¦
 251   2        }
 252   1      
 253   1        if(TIM == Timer1)
 254   1        {
 255   2          TR1 = 0;    //Í£Ö¹¼ÆÊý
 256   2          if(TIMx->TIM_Interrupt == ENABLE)   ET1 = 1;  //ÔÊÐíÖÐ¶Ï
 257   2          else                  ET1 = 0;  //½ûÖ¹ÖÐ¶Ï
 258   2          if(TIMx->TIM_Polity == PolityHigh)    PT1 = 1;  //¸ßÓÅÏÈ¼¶ÖÐ¶Ï
 259   2          else                  PT1 = 0;  //µÍÓÅÏÈ¼¶ÖÐ¶Ï
 260   2          if(TIMx->TIM_Mode >= TIM_16BitAutoReloadNoMask) return 2; //´íÎó
 261   2          TMOD = (TMOD & ~0x30) | (TIMx->TIM_Mode << 4);  //¹¤×÷Ä£Ê½,0: 16Î»×Ô¶¯ÖØ×°, 1: 16Î»¶¨Ê±/¼ÆÊý, 2: 8Î»×Ô¶¯Ö
             -Ø×°
 262   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_12T)  AUXR &= ~0x40;  //12T
 263   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_1T)   AUXR |=  0x40;  //1T
 264   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_Ext)  TMOD |=  0x40;  //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
 265   2          else                    TMOD &= ~0x40;  //¶¨Ê±
 266   2          if(TIMx->TIM_ClkOut == ENABLE)  INT_CLKO |=  0x02;  //Êä³öÊ±ÖÓ
 267   2          else              INT_CLKO &= ~0x02;  //²»Êä³öÊ±ÖÓ
 268   2          
 269   2          TH1 = (uint8_t)(TIMx->TIM_Value >> 8);
 270   2          TL1 = (uint8_t)TIMx->TIM_Value;
 271   2          if(TIMx->TIM_Run == ENABLE) TR1 = 1;  //¿ªÊ¼ÔËÐÐ
 272   2          return  0;    //³É¹¦
 273   2        }
 274   1      
 275   1        if(TIM == Timer2)   
 276   1        {
 277   2          AUXR &= ~(1<<4);  //Í£Ö¹¼ÆÊý
 278   2          if(TIMx->TIM_Interrupt == ENABLE)     IE2  |=  (1<<2);  //ÔÊÐíÖÐ¶Ï
 279   2          else                    IE2  &= ~(1<<2);  //½ûÖ¹ÖÐ¶Ï
 280   2          if(TIMx->TIM_ClkSource >  TIM_CLOCK_Ext)  return 2;
 281   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_12T)  AUXR &= ~(1<<2);  //12T
 282   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_1T)   AUXR |=  (1<<2);  //1T
 283   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_Ext)  AUXR |=  (1<<3);  //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
 284   2          else                    AUXR &= ~(1<<3);  //¶¨Ê±
 285   2          if(TIMx->TIM_ClkOut == ENABLE)  INT_CLKO |=  0x04;  //Êä³öÊ±ÖÓ
 286   2          else              INT_CLKO &= ~0x04;  //²»Êä³öÊ±ÖÓ
 287   2      
 288   2          T2H = (uint8_t)(TIMx->TIM_Value >> 8);
 289   2          T2L = (uint8_t)TIMx->TIM_Value;
 290   2          if(TIMx->TIM_Run == ENABLE) AUXR |=  (1<<4);  //¿ªÊ¼ÔËÐÐ
 291   2          return  0;    //³É¹¦
 292   2        }
 293   1        return 2; //´íÎó
 294   1      }
C51 COMPILER V9.60.7.0   RICHBOT_TIMER                                                     12/19/2023 09:15:26 PAGE 6   

 295          #endif
 296          
 297          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    726    ----
   CONSTANT SIZE    =      2    ----
   XDATA SIZE       =   ----      18
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =      4    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
